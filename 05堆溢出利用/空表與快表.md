# 空表與快表

這是搭配著書看的筆記

![enter image description here](https://i.imgur.com/W59UTCW.png)

-----

### 要用attach方式

![enter image description here](https://i.imgur.com/qqV22LO.png)

---







空閒與占用塊的區別

![enter image description here](https://i.imgur.com/GRlxCAX.png)



![enter image description here](https://i.imgur.com/a8iK1b2.png)

----


## 計算塊的單位為8bytes


### 注意 觀察發現塊首的 2 -3 bytes 記錄著自己上面的塊大小

![enter image description here](https://i.imgur.com/wYIBz6F.png)

0002 = 02 * 8(塊單位) =16 bytes

h2 的塊首中，說明了 h1 是16 bytes

---







### 調適空表 free (用release 版本)

```
#include <windows.h>
main()
{
	HLOCAL h1,h2,h3,h4,h5,h6;
	HANDLE hp;
	hp = HeapCreate(0,0x1000,0x10000);
	__asm int 3

	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19);
	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);
	
	//free block and prevent coaleses
	HeapFree(hp,0,h1); //free to freelist[2] 
	HeapFree(hp,0,h3); //free to freelist[2] 
	HeapFree(hp,0,h5); //free to freelist[4]
	
	HeapFree(hp,0,h4); //coalese h3,h4,h5,link the large block to freelist[8]

	
	return 0;
}

```

-----------------------


![enter image description here](https://i.imgur.com/YHFeDEb.jpg)


我只畫出每一塊被分配到的地址，並沒有畫出釋放空塊後的 flink 和 blink (幫助以後複習)


總結一下
空表是雙向串列結構，是一個環狀
free[0] 接收大塊
free[2] 這條鍊只接收 16 bytes 的塊 (包含 塊首 + 塊身)

----

![enter image description here](https://i.imgur.com/B2uH6WH.png)

```
```

### 調適快表 (用release 版本)


```
#include <stdio.h>
#include <windows.h>
void main()
{
	HLOCAL h1,h2,h3,h4;
	HANDLE hp;
	hp = HeapCreate(0,0,0);
	__asm int 3
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);
	HeapFree(hp,0,h1);
	HeapFree(hp,0,h2);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h4);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	HeapFree(hp,0,h2);
}
```
----------------------

![enter image description here](https://i.imgur.com/g1X8R7r.jpg)


調適時候發現的問題
1.lookaside[1] 接受 8bytes  但 h1 h2  ( 塊首+塊身=16 bytes)  卻被鍊入了(我想大概跟快表永遠不合併有關。)

上面空表 free[1] 是接受8 bytes
上面空表 free[2] 是接受16 bytes      h1 h2  ( 塊首+塊身=16 bytes) 被鍊入了。


2.快表是單向串鍊
研究發現似乎是往後串 look[1]-> h2 -> h1 -> null (00)，也就是說應該是先找到最尾端的空塊再給程式使用。


